// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: transaction.proto

#ifndef PROTOBUF_INCLUDED_transaction_2eproto
#define PROTOBUF_INCLUDED_transaction_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_transaction_2eproto 

namespace cbdc {
    namespace transaction {
        struct full_tx;
    }
}

namespace protobuf_transaction_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_transaction_2eproto
namespace transaction {
class Input;
class InputDefaultTypeInternal;
extern InputDefaultTypeInternal _Input_default_instance_;
class Outpoint;
class OutpointDefaultTypeInternal;
extern OutpointDefaultTypeInternal _Outpoint_default_instance_;
class Output;
class OutputDefaultTypeInternal;
extern OutputDefaultTypeInternal _Output_default_instance_;
class Transaction;
class TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
class TransactionRequest;
class TransactionRequestDefaultTypeInternal;
extern TransactionRequestDefaultTypeInternal _TransactionRequest_default_instance_;
class TransactionResponse;
class TransactionResponseDefaultTypeInternal;
extern TransactionResponseDefaultTypeInternal _TransactionResponse_default_instance_;
class Witness;
class WitnessDefaultTypeInternal;
extern WitnessDefaultTypeInternal _Witness_default_instance_;
}  // namespace transaction
namespace google {
namespace protobuf {
template<> ::transaction::Input* Arena::CreateMaybeMessage<::transaction::Input>(Arena*);
template<> ::transaction::Outpoint* Arena::CreateMaybeMessage<::transaction::Outpoint>(Arena*);
template<> ::transaction::Output* Arena::CreateMaybeMessage<::transaction::Output>(Arena*);
template<> ::transaction::Transaction* Arena::CreateMaybeMessage<::transaction::Transaction>(Arena*);
template<> ::transaction::TransactionRequest* Arena::CreateMaybeMessage<::transaction::TransactionRequest>(Arena*);
template<> ::transaction::TransactionResponse* Arena::CreateMaybeMessage<::transaction::TransactionResponse>(Arena*);
template<> ::transaction::Witness* Arena::CreateMaybeMessage<::transaction::Witness>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace transaction {

// ===================================================================

class Outpoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transaction.Outpoint) */ {
 public:
  Outpoint();
  virtual ~Outpoint();

  Outpoint(const Outpoint& from);

  inline Outpoint& operator=(const Outpoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Outpoint(Outpoint&& from) noexcept
    : Outpoint() {
    *this = ::std::move(from);
  }

  inline Outpoint& operator=(Outpoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Outpoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Outpoint* internal_default_instance() {
    return reinterpret_cast<const Outpoint*>(
               &_Outpoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Outpoint* other);
  friend void swap(Outpoint& a, Outpoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Outpoint* New() const final {
    return CreateMaybeMessage<Outpoint>(NULL);
  }

  Outpoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Outpoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Outpoint& from);
  void MergeFrom(const Outpoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Outpoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes transaction_id = 1;
  void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 1;
  const ::std::string& transaction_id() const;
  void set_transaction_id(const ::std::string& value);
  #if LANG_CXX11
  void set_transaction_id(::std::string&& value);
  #endif
  void set_transaction_id(const char* value);
  void set_transaction_id(const void* value, size_t size);
  ::std::string* mutable_transaction_id();
  ::std::string* release_transaction_id();
  void set_allocated_transaction_id(::std::string* transaction_id);

  // uint64 index = 2;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::uint64 index() const;
  void set_index(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:transaction.Outpoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr transaction_id_;
  ::google::protobuf::uint64 index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_transaction_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Output : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transaction.Output) */ {
 public:
  Output();
  virtual ~Output();

  Output(const Output& from);

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Output(Output&& from) noexcept
    : Output() {
    *this = ::std::move(from);
  }

  inline Output& operator=(Output&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Output& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Output* internal_default_instance() {
    return reinterpret_cast<const Output*>(
               &_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Output* other);
  friend void swap(Output& a, Output& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Output* New() const final {
    return CreateMaybeMessage<Output>(NULL);
  }

  Output* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Output>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Output& from);
  void MergeFrom(const Output& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Output* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes public_key = 1;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // uint64 value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::uint64 value() const;
  void set_value(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:transaction.Output)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::uint64 value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_transaction_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Input : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transaction.Input) */ {
 public:
  Input();
  virtual ~Input();

  Input(const Input& from);

  inline Input& operator=(const Input& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Input(Input&& from) noexcept
    : Input() {
    *this = ::std::move(from);
  }

  inline Input& operator=(Input&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Input& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Input* internal_default_instance() {
    return reinterpret_cast<const Input*>(
               &_Input_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Input* other);
  friend void swap(Input& a, Input& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Input* New() const final {
    return CreateMaybeMessage<Input>(NULL);
  }

  Input* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Input>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Input& from);
  void MergeFrom(const Input& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Input* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .transaction.Outpoint outpoint = 1;
  bool has_outpoint() const;
  void clear_outpoint();
  static const int kOutpointFieldNumber = 1;
  private:
  const ::transaction::Outpoint& _internal_outpoint() const;
  public:
  const ::transaction::Outpoint& outpoint() const;
  ::transaction::Outpoint* release_outpoint();
  ::transaction::Outpoint* mutable_outpoint();
  void set_allocated_outpoint(::transaction::Outpoint* outpoint);

  // .transaction.Output output = 2;
  bool has_output() const;
  void clear_output();
  static const int kOutputFieldNumber = 2;
  private:
  const ::transaction::Output& _internal_output() const;
  public:
  const ::transaction::Output& output() const;
  ::transaction::Output* release_output();
  ::transaction::Output* mutable_output();
  void set_allocated_output(::transaction::Output* output);

  // @@protoc_insertion_point(class_scope:transaction.Input)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::transaction::Outpoint* outpoint_;
  ::transaction::Output* output_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_transaction_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Witness : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transaction.Witness) */ {
 public:
  Witness();
  virtual ~Witness();

  Witness(const Witness& from);

  inline Witness& operator=(const Witness& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Witness(Witness&& from) noexcept
    : Witness() {
    *this = ::std::move(from);
  }

  inline Witness& operator=(Witness&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Witness& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Witness* internal_default_instance() {
    return reinterpret_cast<const Witness*>(
               &_Witness_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Witness* other);
  friend void swap(Witness& a, Witness& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Witness* New() const final {
    return CreateMaybeMessage<Witness>(NULL);
  }

  Witness* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Witness>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Witness& from);
  void MergeFrom(const Witness& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Witness* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes signature = 1;
  void clear_signature();
  static const int kSignatureFieldNumber = 1;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:transaction.Witness)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_transaction_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Transaction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transaction.Transaction) */ {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transaction(Transaction&& from) noexcept
    : Transaction() {
    *this = ::std::move(from);
  }

  inline Transaction& operator=(Transaction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Transaction* other);
  friend void swap(Transaction& a, Transaction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transaction* New() const final {
    return CreateMaybeMessage<Transaction>(NULL);
  }

  Transaction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Transaction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  cbdc::transaction::full_tx to_full_tx();

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .transaction.Input inputs = 1;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 1;
  ::transaction::Input* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField< ::transaction::Input >*
      mutable_inputs();
  const ::transaction::Input& inputs(int index) const;
  ::transaction::Input* add_inputs();
  const ::google::protobuf::RepeatedPtrField< ::transaction::Input >&
      inputs() const;

  // repeated .transaction.Output outputs = 2;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 2;
  ::transaction::Output* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField< ::transaction::Output >*
      mutable_outputs();
  const ::transaction::Output& outputs(int index) const;
  ::transaction::Output* add_outputs();
  const ::google::protobuf::RepeatedPtrField< ::transaction::Output >&
      outputs() const;

  // repeated .transaction.Witness witnesses = 3;
  int witnesses_size() const;
  void clear_witnesses();
  static const int kWitnessesFieldNumber = 3;
  ::transaction::Witness* mutable_witnesses(int index);
  ::google::protobuf::RepeatedPtrField< ::transaction::Witness >*
      mutable_witnesses();
  const ::transaction::Witness& witnesses(int index) const;
  ::transaction::Witness* add_witnesses();
  const ::google::protobuf::RepeatedPtrField< ::transaction::Witness >&
      witnesses() const;

  // @@protoc_insertion_point(class_scope:transaction.Transaction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::transaction::Input > inputs_;
  ::google::protobuf::RepeatedPtrField< ::transaction::Output > outputs_;
  ::google::protobuf::RepeatedPtrField< ::transaction::Witness > witnesses_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_transaction_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransactionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transaction.TransactionRequest) */ {
 public:
  TransactionRequest();
  virtual ~TransactionRequest();

  TransactionRequest(const TransactionRequest& from);

  inline TransactionRequest& operator=(const TransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransactionRequest(TransactionRequest&& from) noexcept
    : TransactionRequest() {
    *this = ::std::move(from);
  }

  inline TransactionRequest& operator=(TransactionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransactionRequest* internal_default_instance() {
    return reinterpret_cast<const TransactionRequest*>(
               &_TransactionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(TransactionRequest* other);
  friend void swap(TransactionRequest& a, TransactionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransactionRequest* New() const final {
    return CreateMaybeMessage<TransactionRequest>(NULL);
  }

  TransactionRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransactionRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransactionRequest& from);
  void MergeFrom(const TransactionRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .transaction.Transaction transactions = 1;
  int transactions_size() const;
  void clear_transactions();
  static const int kTransactionsFieldNumber = 1;
  ::transaction::Transaction* mutable_transactions(int index);
  ::google::protobuf::RepeatedPtrField< ::transaction::Transaction >*
      mutable_transactions();
  const ::transaction::Transaction& transactions(int index) const;
  ::transaction::Transaction* add_transactions();
  const ::google::protobuf::RepeatedPtrField< ::transaction::Transaction >&
      transactions() const;

  // @@protoc_insertion_point(class_scope:transaction.TransactionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::transaction::Transaction > transactions_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_transaction_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransactionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transaction.TransactionResponse) */ {
 public:
  TransactionResponse();
  virtual ~TransactionResponse();

  TransactionResponse(const TransactionResponse& from);

  inline TransactionResponse& operator=(const TransactionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransactionResponse(TransactionResponse&& from) noexcept
    : TransactionResponse() {
    *this = ::std::move(from);
  }

  inline TransactionResponse& operator=(TransactionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransactionResponse* internal_default_instance() {
    return reinterpret_cast<const TransactionResponse*>(
               &_TransactionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(TransactionResponse* other);
  friend void swap(TransactionResponse& a, TransactionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransactionResponse* New() const final {
    return CreateMaybeMessage<TransactionResponse>(NULL);
  }

  TransactionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransactionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransactionResponse& from);
  void MergeFrom(const TransactionResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:transaction.TransactionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_transaction_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Outpoint

// bytes transaction_id = 1;
inline void Outpoint::clear_transaction_id() {
  transaction_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Outpoint::transaction_id() const {
  // @@protoc_insertion_point(field_get:transaction.Outpoint.transaction_id)
  return transaction_id_.GetNoArena();
}
inline void Outpoint::set_transaction_id(const ::std::string& value) {
  
  transaction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transaction.Outpoint.transaction_id)
}
#if LANG_CXX11
inline void Outpoint::set_transaction_id(::std::string&& value) {
  
  transaction_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transaction.Outpoint.transaction_id)
}
#endif
inline void Outpoint::set_transaction_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  transaction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transaction.Outpoint.transaction_id)
}
inline void Outpoint::set_transaction_id(const void* value, size_t size) {
  
  transaction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transaction.Outpoint.transaction_id)
}
inline ::std::string* Outpoint::mutable_transaction_id() {
  
  // @@protoc_insertion_point(field_mutable:transaction.Outpoint.transaction_id)
  return transaction_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Outpoint::release_transaction_id() {
  // @@protoc_insertion_point(field_release:transaction.Outpoint.transaction_id)
  
  return transaction_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Outpoint::set_allocated_transaction_id(::std::string* transaction_id) {
  if (transaction_id != NULL) {
    
  } else {
    
  }
  transaction_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transaction_id);
  // @@protoc_insertion_point(field_set_allocated:transaction.Outpoint.transaction_id)
}

// uint64 index = 2;
inline void Outpoint::clear_index() {
  index_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Outpoint::index() const {
  // @@protoc_insertion_point(field_get:transaction.Outpoint.index)
  return index_;
}
inline void Outpoint::set_index(::google::protobuf::uint64 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:transaction.Outpoint.index)
}

// -------------------------------------------------------------------

// Output

// bytes public_key = 1;
inline void Output::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Output::public_key() const {
  // @@protoc_insertion_point(field_get:transaction.Output.public_key)
  return public_key_.GetNoArena();
}
inline void Output::set_public_key(const ::std::string& value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transaction.Output.public_key)
}
#if LANG_CXX11
inline void Output::set_public_key(::std::string&& value) {
  
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transaction.Output.public_key)
}
#endif
inline void Output::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transaction.Output.public_key)
}
inline void Output::set_public_key(const void* value, size_t size) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transaction.Output.public_key)
}
inline ::std::string* Output::mutable_public_key() {
  
  // @@protoc_insertion_point(field_mutable:transaction.Output.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Output::release_public_key() {
  // @@protoc_insertion_point(field_release:transaction.Output.public_key)
  
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Output::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    
  } else {
    
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:transaction.Output.public_key)
}

// uint64 value = 2;
inline void Output::clear_value() {
  value_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Output::value() const {
  // @@protoc_insertion_point(field_get:transaction.Output.value)
  return value_;
}
inline void Output::set_value(::google::protobuf::uint64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:transaction.Output.value)
}

// -------------------------------------------------------------------

// Input

// .transaction.Outpoint outpoint = 1;
inline bool Input::has_outpoint() const {
  return this != internal_default_instance() && outpoint_ != NULL;
}
inline void Input::clear_outpoint() {
  if (GetArenaNoVirtual() == NULL && outpoint_ != NULL) {
    delete outpoint_;
  }
  outpoint_ = NULL;
}
inline const ::transaction::Outpoint& Input::_internal_outpoint() const {
  return *outpoint_;
}
inline const ::transaction::Outpoint& Input::outpoint() const {
  const ::transaction::Outpoint* p = outpoint_;
  // @@protoc_insertion_point(field_get:transaction.Input.outpoint)
  return p != NULL ? *p : *reinterpret_cast<const ::transaction::Outpoint*>(
      &::transaction::_Outpoint_default_instance_);
}
inline ::transaction::Outpoint* Input::release_outpoint() {
  // @@protoc_insertion_point(field_release:transaction.Input.outpoint)
  
  ::transaction::Outpoint* temp = outpoint_;
  outpoint_ = NULL;
  return temp;
}
inline ::transaction::Outpoint* Input::mutable_outpoint() {
  
  if (outpoint_ == NULL) {
    auto* p = CreateMaybeMessage<::transaction::Outpoint>(GetArenaNoVirtual());
    outpoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:transaction.Input.outpoint)
  return outpoint_;
}
inline void Input::set_allocated_outpoint(::transaction::Outpoint* outpoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete outpoint_;
  }
  if (outpoint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      outpoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, outpoint, submessage_arena);
    }
    
  } else {
    
  }
  outpoint_ = outpoint;
  // @@protoc_insertion_point(field_set_allocated:transaction.Input.outpoint)
}

// .transaction.Output output = 2;
inline bool Input::has_output() const {
  return this != internal_default_instance() && output_ != NULL;
}
inline void Input::clear_output() {
  if (GetArenaNoVirtual() == NULL && output_ != NULL) {
    delete output_;
  }
  output_ = NULL;
}
inline const ::transaction::Output& Input::_internal_output() const {
  return *output_;
}
inline const ::transaction::Output& Input::output() const {
  const ::transaction::Output* p = output_;
  // @@protoc_insertion_point(field_get:transaction.Input.output)
  return p != NULL ? *p : *reinterpret_cast<const ::transaction::Output*>(
      &::transaction::_Output_default_instance_);
}
inline ::transaction::Output* Input::release_output() {
  // @@protoc_insertion_point(field_release:transaction.Input.output)
  
  ::transaction::Output* temp = output_;
  output_ = NULL;
  return temp;
}
inline ::transaction::Output* Input::mutable_output() {
  
  if (output_ == NULL) {
    auto* p = CreateMaybeMessage<::transaction::Output>(GetArenaNoVirtual());
    output_ = p;
  }
  // @@protoc_insertion_point(field_mutable:transaction.Input.output)
  return output_;
}
inline void Input::set_allocated_output(::transaction::Output* output) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete output_;
  }
  if (output) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      output = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, output, submessage_arena);
    }
    
  } else {
    
  }
  output_ = output;
  // @@protoc_insertion_point(field_set_allocated:transaction.Input.output)
}

// -------------------------------------------------------------------

// Witness

// bytes signature = 1;
inline void Witness::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Witness::signature() const {
  // @@protoc_insertion_point(field_get:transaction.Witness.signature)
  return signature_.GetNoArena();
}
inline void Witness::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transaction.Witness.signature)
}
#if LANG_CXX11
inline void Witness::set_signature(::std::string&& value) {
  
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transaction.Witness.signature)
}
#endif
inline void Witness::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transaction.Witness.signature)
}
inline void Witness::set_signature(const void* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transaction.Witness.signature)
}
inline ::std::string* Witness::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:transaction.Witness.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Witness::release_signature() {
  // @@protoc_insertion_point(field_release:transaction.Witness.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Witness::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:transaction.Witness.signature)
}

// -------------------------------------------------------------------

// Transaction

// repeated .transaction.Input inputs = 1;
inline int Transaction::inputs_size() const {
  return inputs_.size();
}
inline void Transaction::clear_inputs() {
  inputs_.Clear();
}
inline ::transaction::Input* Transaction::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:transaction.Transaction.inputs)
  return inputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::transaction::Input >*
Transaction::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:transaction.Transaction.inputs)
  return &inputs_;
}
inline const ::transaction::Input& Transaction::inputs(int index) const {
  // @@protoc_insertion_point(field_get:transaction.Transaction.inputs)
  return inputs_.Get(index);
}
inline ::transaction::Input* Transaction::add_inputs() {
  // @@protoc_insertion_point(field_add:transaction.Transaction.inputs)
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::transaction::Input >&
Transaction::inputs() const {
  // @@protoc_insertion_point(field_list:transaction.Transaction.inputs)
  return inputs_;
}

// repeated .transaction.Output outputs = 2;
inline int Transaction::outputs_size() const {
  return outputs_.size();
}
inline void Transaction::clear_outputs() {
  outputs_.Clear();
}
inline ::transaction::Output* Transaction::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:transaction.Transaction.outputs)
  return outputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::transaction::Output >*
Transaction::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:transaction.Transaction.outputs)
  return &outputs_;
}
inline const ::transaction::Output& Transaction::outputs(int index) const {
  // @@protoc_insertion_point(field_get:transaction.Transaction.outputs)
  return outputs_.Get(index);
}
inline ::transaction::Output* Transaction::add_outputs() {
  // @@protoc_insertion_point(field_add:transaction.Transaction.outputs)
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::transaction::Output >&
Transaction::outputs() const {
  // @@protoc_insertion_point(field_list:transaction.Transaction.outputs)
  return outputs_;
}

// repeated .transaction.Witness witnesses = 3;
inline int Transaction::witnesses_size() const {
  return witnesses_.size();
}
inline void Transaction::clear_witnesses() {
  witnesses_.Clear();
}
inline ::transaction::Witness* Transaction::mutable_witnesses(int index) {
  // @@protoc_insertion_point(field_mutable:transaction.Transaction.witnesses)
  return witnesses_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::transaction::Witness >*
Transaction::mutable_witnesses() {
  // @@protoc_insertion_point(field_mutable_list:transaction.Transaction.witnesses)
  return &witnesses_;
}
inline const ::transaction::Witness& Transaction::witnesses(int index) const {
  // @@protoc_insertion_point(field_get:transaction.Transaction.witnesses)
  return witnesses_.Get(index);
}
inline ::transaction::Witness* Transaction::add_witnesses() {
  // @@protoc_insertion_point(field_add:transaction.Transaction.witnesses)
  return witnesses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::transaction::Witness >&
Transaction::witnesses() const {
  // @@protoc_insertion_point(field_list:transaction.Transaction.witnesses)
  return witnesses_;
}

// -------------------------------------------------------------------

// TransactionRequest

// repeated .transaction.Transaction transactions = 1;
inline int TransactionRequest::transactions_size() const {
  return transactions_.size();
}
inline void TransactionRequest::clear_transactions() {
  transactions_.Clear();
}
inline ::transaction::Transaction* TransactionRequest::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:transaction.TransactionRequest.transactions)
  return transactions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::transaction::Transaction >*
TransactionRequest::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:transaction.TransactionRequest.transactions)
  return &transactions_;
}
inline const ::transaction::Transaction& TransactionRequest::transactions(int index) const {
  // @@protoc_insertion_point(field_get:transaction.TransactionRequest.transactions)
  return transactions_.Get(index);
}
inline ::transaction::Transaction* TransactionRequest::add_transactions() {
  // @@protoc_insertion_point(field_add:transaction.TransactionRequest.transactions)
  return transactions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::transaction::Transaction >&
TransactionRequest::transactions() const {
  // @@protoc_insertion_point(field_list:transaction.TransactionRequest.transactions)
  return transactions_;
}

// -------------------------------------------------------------------

// TransactionResponse

// string message = 1;
inline void TransactionResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionResponse::message() const {
  // @@protoc_insertion_point(field_get:transaction.TransactionResponse.message)
  return message_.GetNoArena();
}
inline void TransactionResponse::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transaction.TransactionResponse.message)
}
#if LANG_CXX11
inline void TransactionResponse::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:transaction.TransactionResponse.message)
}
#endif
inline void TransactionResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transaction.TransactionResponse.message)
}
inline void TransactionResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transaction.TransactionResponse.message)
}
inline ::std::string* TransactionResponse::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:transaction.TransactionResponse.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionResponse::release_message() {
  // @@protoc_insertion_point(field_release:transaction.TransactionResponse.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionResponse::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:transaction.TransactionResponse.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace transaction

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_transaction_2eproto
